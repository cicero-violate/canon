// execution_dag.dot
digraph Canon_Execution_DAG {
  label = "Canon Level-7 Execution DAG\n(A â†’ B means A flows into B)";
  labelloc = top;
  fontsize = 18;
  rankdir = LR;
  fontname = "JetBrains Mono";

  node [
    shape=box,
    style=rounded,
    fontname="JetBrains Mono",
    fontsize=10
  ];
  edge [
    fontname="JetBrains Mono",
    fontsize=9
  ];

  /* ===== Declarative Construction ===== */
  DSL [
    label="DSL\n(text input)",
    shape=component
  ];
  Proposal [
    label="Proposal\n(nodes, apis, edges)"
  ];
  ResolvedNodes [
    label="ResolvedProposalNodes\n(ids + bindings)"
  ];
  CanonicalIR [
    label="CanonicalIr\n(validated DAG)"
  ];

  DSL          -> Proposal      [label="parse"];
  Proposal     -> ResolvedNodes [label="resolve ids"];
  ResolvedNodes -> CanonicalIR  [label="validate"];

  /* ===== Judgment & Proof ===== */
  JudgmentValidator [
    label="JudgmentValidator\n(IntentRadius + Policy + JudgmentResult)"
  ];
  JudgmentProof [
    label="JudgmentProof\n(ProofScope + hash)"
  ];

  CanonicalIR       -> JudgmentValidator [label="declare"];
  JudgmentValidator -> JudgmentProof     [label="prove"];

  /* ===== Admission (Gate Only) ===== */
  Admission [
    label="Admission\n(accept / reject)"
  ];

  JudgmentProof     -> Admission [label="certificate"];
  JudgmentValidator -> Admission [label="policy check"];

  /* ===== Kernel (SOLE MUTATION AUTHORITY) ===== */
  Kernel [
    label="Kernel\n(apply + InvariantSet + RootHash)",
    shape=octagon,
    style="rounded,filled",
    fillcolor=lightgray
  ];

  Admission -> Kernel [label="if accepted"];

  /* ===== Delta Generation ===== */
  Delta [
    label="Delta\n(DeltaId + DeltaMask)"
  ];

  Kernel -> Delta [label="emit"];

  /* ===== Append-Only Ledger ===== */
  DeltaLedger [
    label="DeltaLedger\n(append-only ledger)",
    shape=folder
  ];

  Kernel -> DeltaLedger [label="append LedgerEntry"];
  Delta  -> DeltaLedger [label="stored as LedgerEntry"];

  /* ===== Canonical State + Hash ===== */
  CanonicalState [
    label="CanonicalState\n(materialized StateSlice[])"
  ];
  RootHash [
    label="RootHash\n(H(CanonicalState))"
  ];

  DeltaLedger    -> CanonicalState [label="ReplayEngine::replay"];
  CanonicalState -> RootHash       [label="hash::compute"];
}
