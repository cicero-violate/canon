rustc_integration/frontends/rustc/context.rs:
  struct FrontendMetadata  { edition, rust_version, crate_type, target_triple, target_name, workspace_root, package_name, package_version, package_features, cfg_flags }  (line 5)

rustc_integration/frontends/rustc/types.rs:
  fn capture_function_types(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    local_def: LocalDefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
)  (line 13)
  fn collect_type_dependencies(
    tcx: TyCtxt<'tcx>,
    ty: ty::Ty<'tcx>,
    seen: &mut HashSet<DefId>,
)  (line 49)

rustc_integration/frontends/rustc/hir_bodies.rs:
  fn encode_hir_body_json(
    tcx: TyCtxt<'tcx>,
    def_id: LocalDefId,
) -> Option<String>  (line 10)

rustc_integration/frontends/rustc/mod.rs:
  enum RustcFrontendError  { Unavailable, Io, Sysroot, MissingSnapshot }  (line 29)
  impl std::fmt::Display for RustcFrontendError  { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result }  (line 43)
  impl std::error::Error for RustcFrontendError  (line 57)
  impl From<std::io::Error> for RustcFrontendError  { fn from(err: std::io::Error) -> Self }  (line 60)

rustc_integration/frontends/rustc/collector.rs:
  struct RustcFrontend  { edition, crate_type, rust_version, target_name, workspace_root, package_name, package_version, package_features, cfg_flags }  (line 27)
  impl Default for RustcFrontend  { fn default() -> Self }  (line 39)
  impl RustcFrontend  { fn new() -> Self, fn with_crate_type(mut self, crate_type: impl Into<String>) -> Self, fn with_edition(mut self, edition: impl Into<String>) -> Self, fn with_rust_version(mut self, rust_version: impl Into<String>) -> Self, fn with_target_name(mut self, target_name: impl Into<String>) -> Self, fn with_workspace_root(mut self, root: impl Into<PathBuf>) -> Self, fn with_package_info(
        mut self,
        name: impl Into<String>,
        version: impl Into<String>,
    ) -> Self, fn with_package_features(mut self, features: I) -> Self, fn with_cfg_flags(mut self, cfgs: I) -> Self, fn capture_snapshot(
        &self,
        entry: P,
        extra_args: &[String],
        env_vars: &[(String, String)],
    ) -> Result<GraphSnapshot, RustcFrontendError> }  (line 55)
  struct SnapshotCallbacks  { snapshot, metadata }  (line 194)
  impl SnapshotCallbacks  { fn new(metadata: FrontendMetadata) -> Self, fn into_snapshot(self) -> Option<GraphSnapshot> }  (line 199)
  impl Callbacks for SnapshotCallbacks  { fn after_analysis(&mut self, _compiler: &Compiler, tcx: TyCtxt<'tcx>) -> Compilation }  (line 212)
  fn parse_cfg_flags(extra_args: &[String]) -> Vec<String>  (line 219)
  fn build_snapshot_from_tcx(tcx: TyCtxt<'tcx>, metadata: &FrontendMetadata) -> GraphSnapshot  (line 237)
  fn is_supported_def(kind: DefKind) -> bool  (line 289)
  fn resolve_sysroot() -> Result<PathBuf, std::io::Error>  (line 293)

rustc_integration/frontends/rustc/items.rs:
  fn capture_adt(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
) -> NodeId  (line 13)
  fn capture_type_alias(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
) -> NodeId  (line 58)
  fn capture_const_static(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
) -> NodeId  (line 91)
  fn serialize_struct_fields(tcx: TyCtxt<'tcx>, adt_def: ty::AdtDef<'tcx>) -> Option<String>  (line 124)
  fn serialize_enum_variants(tcx: TyCtxt<'tcx>, adt_def: ty::AdtDef<'tcx>) -> Option<String>  (line 157)
  fn classify_adt_kind(adt_def: ty::AdtDef<'_>) -> String  (line 204)

rustc_integration/frontends/rustc/traits.rs:
  fn capture_trait(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
) -> NodeId  (line 14)
  fn capture_impl(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
    of_trait_hint: bool,
) -> NodeId  (line 52)
  fn serialize_associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String>  (line 108)
  fn serialize_impl_items(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String>  (line 136)

rustc_integration/frontends/rustc/nodes.rs:
  fn ensure_node(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
) -> NodeId  (line 15)
  fn serialize_locals(tcx: TyCtxt<'tcx>, local_def: LocalDefId) -> Option<String>  (line 84)
  fn serialize_fn_signature(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<String>  (line 112)

rustc_integration/frontends/rustc/mir.rs:
  fn capture_function(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    local_def: LocalDefId,
    function_node: NodeId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
)  (line 17)
  fn collect_calls(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    body: &mir::Body<'tcx>,
    caller_node: NodeId,
    local_def: LocalDefId,
    cache: &mut HashMap<DefId, NodeId>,
    metadata: &FrontendMetadata,
)  (line 97)
  fn call_span(_tcx: TyCtxt<'tcx>, span: Span, _local_def: LocalDefId) -> Span  (line 138)
  fn serialize_statements(bb_data: &mir::BasicBlockData<'tcx>) -> Option<String>  (line 143)
  fn serialize_cfg_graph(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) -> Option<String>  (line 163)
  fn serialize_dfg(_tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) -> Option<String>  (line 228)
  fn serialize_mir_dump(body: &mir::Body<'tcx>) -> Option<String>  (line 260)
  fn compute_metrics(
    tcx: TyCtxt<'tcx>,
    local_def: LocalDefId,
    body: &mir::Body<'tcx>,
) -> Option<String>  (line 264)
  fn compute_effects(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) -> Option<String>  (line 316)

rustc_integration/frontends/rustc/metadata.rs:
  fn apply_common_metadata(
    mut payload: NodePayload,
    tcx: TyCtxt<'tcx>,
    def_id: DefId,
    frontend: &FrontendMetadata,
) -> NodePayload  (line 16)
  fn capture_attributes(tcx: TyCtxt<'_>, def_id: DefId) -> Option<AttributeData>  (line 144)
  fn attribute_path(attr: &HirAttribute) -> Vec<String>  (line 185)
  fn attribute_args(attr: &HirAttribute) -> Option<String>  (line 189)
  fn serialize_generics(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String>  (line 202)
  fn serialize_predicates(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<String>>  (line 230)
  fn format_param_kind(kind: &GenericParamDefKind) -> String  (line 245)
  fn param_has_default(kind: &GenericParamDefKind) -> bool  (line 253)
  struct GenericsCapture  { params, parent, predicates }  (line 262)
  struct GenericParamCapture  { index, name, kind, has_default }  (line 269)
  struct AttributeData  { raw, flags }  (line 276)
  struct AttributeFlags  { inline, inline_hint, test, bench, no_mangle, doc_hidden, thread_local, reprs, derives, doc }  (line 282)
  impl AttributeFlags  { fn apply(&mut self, attr: &HirAttribute) }  (line 295)
  fn apply_attribute_flags(mut payload: NodePayload, flags: AttributeFlags) -> NodePayload  (line 349)
  struct FileStats  { hash, line_count, byte_len }  (line 387)
  fn source_file_stats(file: &SourceFile) -> FileStats  (line 393)
  fn resolve_absolute_path(filename: &FileName) -> String  (line 413)
  fn resolve_relative_path(path: &str, workspace_root: Option<&str>) -> Option<String>  (line 421)
  fn classify_node_kind(def_kind: DefKind) -> String  (line 430)
  fn module_path(def_path: &str) -> String  (line 450)
  fn format_display(module: &str, name: &str) -> String  (line 454)
  fn classify_symbol_kind(def_kind: DefKind) -> String  (line 462)

rustc_integration/frontends/rustc/crate_meta.rs:
  fn capture_crate_metadata(
    builder: &mut KernelGraphBuilder,
    tcx: TyCtxt<'tcx>,
    metadata: &FrontendMetadata,
)  (line 12)
  fn serialize_dependencies(tcx: TyCtxt<'_>) -> String  (line 58)

rustc_integration/frontends/rustc/stub.rs:
  struct RustcFrontend  (line 6)
  impl RustcFrontend  { fn new() -> Self, fn with_crate_type(self, _crate_type: impl Into<String>) -> Self, fn with_edition(self, _edition: impl Into<String>) -> Self, fn with_rust_version(self, _rust_version: impl Into<String>) -> Self, fn with_target_name(self, _target_name: impl Into<String>) -> Self, fn with_workspace_root(self, _root: impl Into<std::path::PathBuf>) -> Self, fn with_package_info(self, _name: impl Into<String>, _version: impl Into<String>) -> Self, fn with_package_features(self, _features: I) -> Self, fn with_cfg_flags(self, _flags: I) -> Self, fn capture_snapshot(
        &self,
        _entry: P,
        _args: &[String],
        _env_vars: &[(String, String)],
    ) -> Result<GraphSnapshot, RustcFrontendError> }  (line 8)

rustc_integration/kernel_root.rs:
  fn kernel_root(project_root: &PathBuf) -> PathBuf  (line 6)
  fn resolve_project_root() -> PathBuf  (line 12)

rustc_integration/mod.rs:
  trait FrontendExtractor  (line 29)
  struct ExtractionResult  { crate_name, items, errors, warnings, stats, graph }  (line 47)
  impl ExtractionResult  { fn empty(crate_name: impl Into<String>) -> Self }  (line 62)
  struct ExtractionStats  { functions_captured, types_captured, traits_captured, impls_captured, modules_captured, total_items, duration_ms }  (line 78)
  enum CapturedItem  { Function, Struct, Enum, Trait, Impl, Module, TypeAlias, Const, Static }  (line 97)
  struct FunctionCapture  { name, path, signature, metadata }  (line 120)
  struct StructCapture  { name, path, fields, metadata }  (line 133)
  struct EnumCapture  { name, path, variants, metadata }  (line 146)
  struct TraitCapture  { name, path, methods, supertraits, metadata }  (line 159)
  struct ImplCapture  { name, path, target, trait_ref, metadata }  (line 174)
  struct ModuleCapture  { name, path, children, metadata }  (line 189)
  struct TypeAliasCapture  { name, path, aliased_type, metadata }  (line 202)
  struct ConstCapture  { name, path, value_repr, metadata }  (line 215)
  struct StaticCapture  { name, path, value_repr, mutable, metadata }  (line 228)
  struct ExtractionError  { code, message, location }  (line 244)
  impl ExtractionError  { fn new(code: impl Into<String>, message: impl Into<String>) -> Self }  (line 253)
  struct SourceLocation  { file, line, column }  (line 267)

rustc_integration/multi_capture.rs:
  struct CaptureArtifacts  { snapshot, workspace, graph_deltas }  (line 12)
  enum CaptureError  { Generic, Io, Frontend }  (line 20)
  impl std::fmt::Display for CaptureError  { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result }  (line 29)
  impl std::error::Error for CaptureError  (line 39)
  impl From<std::io::Error> for CaptureError  { fn from(err: std::io::Error) -> Self }  (line 41)
  impl From<RustcFrontendError> for CaptureError  { fn from(err: RustcFrontendError) -> Self }  (line 47)
  fn capture_project(
    frontend: &RustcFrontend,
    project: &CargoProject,
    extra_args: &[String],
) -> Result<CaptureArtifacts, CaptureError>  (line 54)
  fn find_out_dir(project: &CargoProject) -> Option<std::path::PathBuf>  (line 166)

rustc_integration/capture/validation.rs:
  fn validate(result: &ExtractionResult) -> bool  (line 6)

rustc_integration/capture/coordinator.rs:
  struct CaptureCoordinator  { dedup, session }  (line 8)
  impl CaptureCoordinator  { fn new() -> Self, fn capture_project_workspace(
        &mut self,
        workspace_root: &Path,
        frontend: &mut F,
    ) -> Result<Vec<ExtractionResult>, Box<dyn Error>>, fn discover_crates(
        &self,
        workspace_root: &Path,
    ) -> Result<Vec<PathBuf>, std::io::Error> }  (line 12)

rustc_integration/capture/dedup.rs:
  struct Deduplicator  (line 7)
  impl Deduplicator  { fn new() -> Self, fn deduplicate(&mut self, mut result: ExtractionResult) -> ExtractionResult }  (line 9)
  fn collapse_duplicates(items: Vec<CapturedItem>) -> Vec<CapturedItem>  (line 22)

rustc_integration/capture/session.rs:
  struct CaptureSession  { runs, crates }  (line 7)
  impl CaptureSession  { fn record(&mut self, result: &ExtractionResult) }  (line 14)

rustc_integration/transform/resolver.rs:
  struct Resolver  (line 5)
  impl Resolver  { fn new() -> Self, fn resolve(&mut self) }  (line 7)

rustc_integration/transform/linker.rs:
  struct Linker  (line 5)
  impl Linker  { fn new() -> Self, fn link(&mut self) }  (line 7)

rustc_integration/transform/normalizer.rs:
  struct GraphNormalizer  (line 14)
  impl GraphNormalizer  { fn new() -> Self, fn normalize(&mut self, items: &[CapturedItem]) -> GraphSnapshot, fn emit_deltas(&self, item: &CapturedItem) -> Vec<GraphDelta> }  (line 16)
  fn make_node_record(
    path: &str,
    label: &str,
    kind: &str,
    metadata: std::collections::HashMap<String, String>,
    signature: Option<String>,
) -> NodeRecord  (line 134)
  fn parent_key(path: &str) -> Option<String>  (line 158)

rustc_integration/project.rs:
  struct CargoProject  { root, target_dir, oracle }  (line 12)
  impl CargoProject  { fn from_entry(entry: &Path) -> io::Result<Self>, fn with_snapshot(mut self, snapshot: GraphSnapshot) -> Self, fn ensure_dependencies_built(&self) -> io::Result<()>, fn extern_args(&self, profile: &str) -> io::Result<Vec<String>>, fn metadata(&self) -> io::Result<ProjectMetadata>, fn targets(&self) -> io::Result<Vec<CargoTarget>>, fn workspace_root(&self) -> &Path }  (line 17)
  fn find_cargo_root(start: &Path) -> io::Result<PathBuf>  (line 145)
  fn fetch_target_dir(root: &Path) -> io::Result<PathBuf>  (line 155)
  fn load_cargo_metadata(root: &Path) -> io::Result<CargoMetadata>  (line 159)
  enum ArtifactKind  { ProcMacro, Rlib, Rmeta }  (line 174)
  struct Artifact  { path, kind }  (line 180)
  fn classify_artifact(file_name: &str) -> Option<(&str, ArtifactKind)>  (line 184)
  fn select_best_artifact(artifacts: &[Artifact]) -> Option<PathBuf>  (line 199)
  struct CargoMetadata  { target_directory, workspace_root, packages }  (line 221)
  struct CargoPackage  { name, version, edition, rust_version, features, targets, manifest_path }  (line 228)
  struct CargoTarget  { name, kind, src_path }  (line 246)
  struct ProjectMetadata  { workspace_root, target_directory, packages, edition, rust_version }  (line 256)
  struct OracleData  { adjacency, macro_generated, crate_by_key, signature_by_key }  (line 269)
  impl OracleData  { fn from_snapshot(snapshot: GraphSnapshot) -> Self }  (line 275)
  fn is_macro_generated(metadata: &std::collections::BTreeMap<String, String>) -> bool  (line 316)
  impl StructuralEditOracle for CargoProject  { fn impact_of(&self, symbol_id: &str) -> Vec<String>, fn satisfies_bounds(&self, id: &str, new_sig: &syn::Signature) -> bool, fn is_macro_generated(&self, symbol_id: &str) -> bool, fn cross_crate_users(&self, symbol_id: &str) -> Vec<String> }  (line 324)

rustc_integration/linux/mod.rs:
  fn capture_linux_state(facts: &[LinuxFact]) -> GraphSnapshot  (line 9)
  fn fact_to_node(fact: &LinuxFact) -> (String, String, BTreeMap<String, String>)  (line 24)

state/ids.rs:
  struct NodeId  (line 5)
  impl NodeId  { fn from_bytes(bytes: [u8; 16]) -> Self, fn from_key(key: &str) -> Self }  (line 7)
  struct EdgeId  (line 24)
  impl EdgeId  { fn from_components(from: &NodeId, to: &NodeId, kind: &str) -> Self }  (line 26)

state/capability/shell.rs:
  enum LinuxFact  { Exists, File, Dir, ProcessRunning, BinaryInstalled }  (line 4)
  fn probe_fact(fact: &LinuxFact) -> bool  (line 12)
  fn binary_on_path(name: &str) -> bool  (line 25)
  fn exists_executable(path: &Path) -> bool  (line 39)

state/workspace.rs:
  struct GraphWorkspace  { hash }  (line 2)
  impl GraphWorkspace  { fn hash(&self) -> u64 }  (line 6)
  struct WorkspaceBuilder  { hash }  (line 13)
  impl WorkspaceBuilder  { fn new(hash: u64) -> Self, fn finalize(self) -> GraphWorkspace }  (line 17)

state/node.rs:
  struct NodeHandle  { file, item_index, nested_path, kind }  (line 6)
  enum NodeKind  { Fn, Struct, Enum, Trait, Impl, ImplFn, Use, Mod, Type, Const }  (line 19)
  struct NodeRegistry  { handles, asts }  (line 34)
  impl NodeRegistry  { fn new() -> Self, fn insert_handle(&mut self, symbol_id: impl Into<String>, handle: NodeHandle), fn insert_ast(&mut self, file: impl Into<PathBuf>, ast: syn::File) }  (line 41)

state/graph.rs:
  enum EdgeKind  { Contains, Call, ControlFlow, Reference }  (line 8)
  impl EdgeKind  { fn as_str(&self) -> &'static str }  (line 15)
  struct NodeRecord  { id, key, label, metadata }  (line 27)
  struct EdgeRecord  { id, from, to, kind, metadata }  (line 35)
  enum GraphDelta  { AddNode, AddEdge }  (line 44)
  enum GraphDeltaError  { NodeExists, EdgeExists, NodeMissing }  (line 50)
  impl std::fmt::Display for GraphDeltaError  { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result }  (line 56)
  impl std::error::Error for GraphDeltaError  (line 66)
  struct GraphSnapshot  { nodes, edges, hash }  (line 69)
  impl GraphSnapshot  { fn new(nodes: Vec<NodeRecord>, edges: Vec<EdgeRecord>) -> Self, fn nodes(&self) -> &[NodeRecord], fn edges(&self) -> &[EdgeRecord], fn hash(&self) -> u64 }  (line 75)
  struct GraphMaterializer  { nodes, edges }  (line 102)
  impl GraphMaterializer  { fn new() -> Self, fn apply(&mut self, delta: GraphDelta) -> Result<(), GraphDeltaError>, fn snapshot(&self) -> GraphSnapshot }  (line 107)

state/builder.rs:
  struct NodePayload  { key, label, metadata }  (line 8)
  impl NodePayload  { fn new(key: impl Into<String>, label: impl Into<String>) -> Self, fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self }  (line 14)
  struct EdgePayload  { from, to, kind, metadata }  (line 30)
  impl EdgePayload  { fn new(from: NodeId, to: NodeId, kind: EdgeKind) -> Self, fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self }  (line 37)
  struct KernelGraphBuilder  { materializer }  (line 54)
  impl KernelGraphBuilder  { fn new() -> Self, fn add_node(&mut self, payload: NodePayload) -> Result<NodeId, GraphDeltaError>, fn add_edge(&mut self, payload: EdgePayload) -> Result<EdgeId, GraphDeltaError>, fn merge_node_metadata(
        &mut self,
        node_id: NodeId,
        updates: I,
    ) -> Result<(), GraphDeltaError>, fn snapshot(&self) -> super::graph::GraphSnapshot, fn finalize(&self) -> super::graph::GraphSnapshot }  (line 58)

fs.rs:
  struct DiscoveredFiles  { rust_files, auxiliary_files }  (line 9)
  struct AuxiliaryFile  { path, kind }  (line 15)
  enum AuxiliaryKind  { CargoToml, BuildScript }  (line 21)
  fn collect_rs_files(root: &Path) -> Result<Vec<PathBuf>>  (line 27)
  fn discover_all_files(root: &Path) -> Result<DiscoveredFiles>  (line 33)
  fn discover_include_targets(files: &[PathBuf]) -> Result<Vec<PathBuf>>  (line 90)
  struct IncludeVisitor  { base_path, targets }  (line 114)
  impl Visit<'ast> for IncludeVisitor<'_>  { fn visit_macro(&mut self, mac: &'ast syn::Macro), fn visit_expr_macro(&mut self, expr: &'ast syn::ExprMacro) }  (line 119)
  fn is_ignored_dir(path: &Path) -> bool  (line 145)

rename/scope.rs:
  struct ScopeFrame  { bindings, parent }  (line 7)
  impl ScopeFrame  { fn new(parent: Option<usize>) -> Self }  (line 13)
  struct ScopeBinder  { scopes, current_scope, symbol_table_ref }  (line 23)
  impl ScopeBinder  { fn new(symbol_table: &SymbolIndex) -> Self, fn push_scope(&mut self), fn pop_scope(&mut self), fn bind(&mut self, name: String, type_path: String), fn resolve(&self, name: &str) -> Option<&String>, fn resolve_method(&self, receiver_type: &str, method_name: &str) -> Option<String>, fn get_method_return_type(&self, receiver_type: &str, method_name: &str) -> Option<String> }  (line 31)

rename/attributes.rs:
  fn extract_symbols_from_attributes(attrs: &[Attribute]) -> Vec<(String, Span)>  (line 8)
  fn extract_identifiers_from_token_string(
    tokens: &str,
    symbols: &mut Vec<(String, Span)>,
    span: Span,
)  (line 63)
  fn is_valid_ident_char(s: &str) -> bool  (line 78)
  fn extract_doc_references(doc_text: &str, symbols: &mut Vec<(String, Span)>, span: Span)  (line 94)
  fn extract_bracket_references(doc_text: &str, symbols: &mut Vec<(String, Span)>, span: Span)  (line 123)
  fn is_likely_symbol_ref(s: &str) -> bool  (line 145)

rename/structured/doc_attr.rs:
  struct StructuredAttributeResult  { literal_spans, changed }  (line 11)
  impl StructuredAttributeResult  { fn new() -> Self, fn should_skip(&self, span: &SpanRange) -> bool }  (line 16)
  struct DocAttrPass  { mapping, config }  (line 29)
  impl DocAttrPass  { fn new(mapping: HashMap<String, String>, config: StructuredEditOptions) -> Self }  (line 34)
  impl StructuredPass for DocAttrPass  { fn name(&self) -> &'static str, fn execute(
        &mut self,
        file: &Path,
        content: &str,
        ast: &mut syn::File,
    ) -> Result<bool>, fn is_enabled(&self) -> bool }  (line 40)
  fn rewrite_doc_and_attr_literals(
    _file: &Path,
    _content: &str,
    ast: &mut syn::File,
    mapping: &HashMap<String, String>,
    config: &StructuredEditOptions,
) -> Result<StructuredAttributeResult>  (line 66)
  struct AttributeRewriteVisitor  { replacements, rewrite_docs, rewrite_attrs, result }  (line 78)
  impl AttributeRewriteVisitor  { fn new(
        mapping: &HashMap<String, String>,
        config: &StructuredEditOptions,
    ) -> Self, fn finish(self) -> StructuredAttributeResult, fn process_attribute(&mut self, attr: &mut syn::Attribute) }  (line 85)
  impl VisitMut for AttributeRewriteVisitor  { fn visit_attribute_mut(&mut self, attr: &mut syn::Attribute) }  (line 130)
  fn build_replacements(mapping: &HashMap<String, String>) -> Vec<(String, String)>  (line 136)
  fn rewrite_literal(value: &str, replacements: &[(String, String)]) -> Option<String>  (line 148)
  fn replace_identifier(text: &str, old: &str, new_name: &str) -> Option<String>  (line 162)
  fn is_boundary(text: &str, start: usize, end: usize) -> bool  (line 186)
  fn contains(outer: &SpanRange, inner: &SpanRange) -> bool  (line 196)

rename/structured/ops.rs:
  enum NodeOp  { ReplaceNode, InsertBefore, InsertAfter, DeleteNode, MutateField, ReorderItems }  (line 7)
  enum FieldMutation  { RenameIdent, ChangeVisibility, AddAttribute, RemoveAttribute, ReplaceSignature, AddStructField, RemoveStructField, AddVariant, RemoveVariant }  (line 18)
  fn node_handle(
    file: impl Into<PathBuf>,
    item_index: usize,
    nested_path: Vec<usize>,
    kind: NodeKind,
) -> NodeHandle  (line 31)

rename/structured/orchestrator.rs:
  trait StructuredPass  { fn is_enabled(&self) -> bool }  (line 8)
  struct StructuredPassRunner  { passes }  (line 20)
  impl StructuredPassRunner  { fn new() -> Self, fn add_pass(&mut self, pass: Box<dyn StructuredPass>), fn execute_passes(
        &mut self,
        file: &Path,
        content: &str,
        ast: &mut syn::File,
    ) -> Result<Vec<&'static str>>, fn count_enabled_passes(&self) -> usize }  (line 23)
  impl Default for StructuredPassRunner  { fn default() -> Self }  (line 51)
  fn create_rename_orchestrator(
    mapping: &HashMap<String, String>,
    path_updates: &HashMap<String, String>,
    alias_nodes: Vec<ImportNode>,
    config: StructuredEditOptions,
) -> StructuredPassRunner  (line 56)

rename/structured/config.rs:
  struct StructuredEditOptions  { doc_literals, attr_literals, use_statements }  (line 2)
  impl StructuredEditOptions  { fn new(doc_literals: bool, attr_literals: bool, use_statements: bool) -> Self, fn disabled() -> Self, fn are_all_passes_enabled() -> Self, fn is_enabled(&self) -> bool, fn doc_literals_enabled(&self) -> bool, fn attr_literals_enabled(&self) -> bool, fn doc_or_attr_enabled(&self) -> bool, fn use_statements_enabled(&self) -> bool, fn summary(&self) -> String }  (line 7)
  fn are_structured_edits_enabled() -> bool  (line 50)
  fn structured_edit_config() -> StructuredEditOptions  (line 53)
  fn env_flag(key: &str, default: bool) -> bool  (line 67)

rename/structured/edits.rs:
  struct AstEdit  { file, start, end, replacement }  (line 11)
  impl AstEdit  { fn replace(
        file: impl Into<PathBuf>,
        start: usize,
        end: usize,
        node: &T,
    ) -> Self, fn insert(file: impl Into<PathBuf>, offset: usize, node: &T) -> Self }  (line 18)
  fn apply_ast_rewrites(edits: &[AstEdit], format: bool) -> Result<Vec<PathBuf>>  (line 43)
  fn insert_items_at_offset(
    ast: &mut syn::File,
    content: &str,
    offset: usize,
    mut items: Vec<syn::Item>,
) -> Result<bool>  (line 104)
  fn replace_items_in_range(
    ast: &mut syn::File,
    content: &str,
    start: usize,
    end: usize,
    items: Vec<syn::Item>,
) -> Result<bool>  (line 121)
  fn find_insert_index(ast: &syn::File, content: &str, offset: usize) -> usize  (line 155)
  fn span_to_line_column(point: proc_macro2::LineColumn) -> LineColumn  (line 170)

rename/structured/use_tree.rs:
  struct UsePathRewritePass  { path_updates, _alias_nodes, config }  (line 11)
  impl UsePathRewritePass  { fn new(
        path_updates: HashMap<String, String>,
        alias_nodes: Vec<ImportNode>,
        config: StructuredEditOptions,
    ) -> Self }  (line 17)
  impl StructuredPass for UsePathRewritePass  { fn name(&self) -> &'static str, fn execute(
        &mut self,
        _file: &Path,
        _content: &str,
        ast: &mut syn::File,
    ) -> Result<bool>, fn is_enabled(&self) -> bool }  (line 31)
  struct UseAstRewriter  { updates, changed }  (line 69)
  impl VisitMut for UseAstRewriter<'a>  { fn visit_item_use_mut(&mut self, node: &mut syn::ItemUse) }  (line 74)
  fn rewrite_use_tree_mut(
    tree: &mut syn::UseTree,
    updates: &HashMap<String, String>,
    changed: &mut bool,
    current_path: &mut Vec<String>,
)  (line 85)
  fn find_replacement_path(path: &str, updates: &HashMap<String, String>) -> Option<String>  (line 159)
  fn extract_segment_replacement(path: &str, new_path: &str, segment_index: usize) -> String  (line 179)

rename/structured/ast_render.rs:
  fn render_node(node: T) -> String  (line 3)
  fn render_file(ast: &syn::File) -> String  (line 12)
  fn render_fn_item(func: &syn::ItemFn) -> String  (line 15)
  fn render_impl_item(item: &syn::ItemImpl) -> String  (line 18)
  fn render_struct(item: &syn::ItemStruct) -> String  (line 21)
  fn render_trait(item: &syn::ItemTrait) -> String  (line 24)

rename/module_path.rs:
  struct ModulePath  { segments, is_inline }  (line 6)
  impl ModulePath  { fn new(segments: Vec<String>) -> Self, fn from_string(path: &str) -> Self, fn to_string(&self) -> String, fn parent(&self) -> Option<ModulePath>, fn last_segment(&self) -> Option<&str> }  (line 12)
  enum ModuleLayout  { Inline, File, DirectoryModRs, DirectoryNamed }  (line 35)
  impl ModuleLayout  { fn file_path(&self) -> Option<&Path>, fn is_dir_path(&self) -> bool }  (line 45)
  fn compute_module_path(project_root: &Path, file_path: &Path) -> Result<String>  (line 61)
  fn detect_module_layout(file_path: &Path) -> ModuleLayout  (line 88)
  struct ModuleMovePlan  { from_path, to_path, from_file, to_file, create_directory, layout_change }  (line 107)
  enum LayoutChange  { InlineToFile, FileToInline, DirectoryLayoutChange }  (line 122)
  impl ModuleMovePlan  { fn new(
        from_path: ModulePath,
        to_path: ModulePath,
        from_file: PathBuf,
        project_root: &Path,
    ) -> Result<Self> }  (line 130)
  fn compute_new_file_path(
    module_path: &ModulePath,
    project_root: &Path,
) -> Result<PathBuf>  (line 155)
  fn inline_mod_to_file_plan(
    module_name: &str,
    parent_file: &Path,
    project_root: &Path,
) -> Result<ModuleMovePlan>  (line 177)
  fn file_mod_to_inline_plan(
    file_path: &Path,
    target_parent_file: &Path,
    project_root: &Path,
) -> Result<ModuleMovePlan>  (line 202)

rename/core/use_paths.rs:
  fn update_use_paths(
    project: &std::path::Path,
    file_renames: &[super::types::FileRename],
    structured_config: &StructuredEditOptions,
    alias_graph: &AliasGraph,
    structured_tracker: &mut StructuredEditTracker,
    touched_files: &mut HashSet<PathBuf>,
) -> Result<()>  (line 9)

rename/core/rename.rs:
  fn apply_rename_with_map(
    project: &Path,
    mapping: &HashMap<String, String>,
    dry_run: bool,
    out_path: Option<&Path>,
) -> Result<()>  (line 22)
  struct SpanRangeKey  { start_line, start_col, end_line, end_col }  (line 256)
  impl SpanRangeKey  { fn from_range(range: &SpanRange) -> Self, fn from_span(span: Span) -> Self }  (line 262)
  fn apply_symbol_edits_to_ast(ast: &mut syn::File, edits: &[SymbolEdit]) -> Result<bool>  (line 275)
  struct SpanRangeRenamer  { map, changed }  (line 305)
  impl VisitMut for SpanRangeRenamer  { fn visit_ident_mut(&mut self, ident: &mut syn::Ident) }  (line 309)
  fn is_valid_ident(name: &str) -> bool  (line 321)
  fn apply_rename(
    project: &Path,
    map_path: &Path,
    dry_run: bool,
    out_path: Option<&Path>,
) -> Result<()>  (line 331)

rename/core/types.rs:
  struct SymbolIndexReport  { version, symbols, occurrences, alias_graph, visibility_analysis }  (line 7)
  struct AliasGraphReport  { use_nodes, edge_count, total_imports, total_reexports, glob_imports }  (line 16)
  struct SymbolRecord  { id, kind, name, module, file, declaration_file, definition_file, span, alias, doc_comments, attributes }  (line 25)
  struct SymbolOccurrence  { id, file, kind, span }  (line 42)
  struct SpanRange  { start, end }  (line 50)
  struct LineColumn  { line, column }  (line 56)
  struct SymbolIndex  { symbols }  (line 62)
  struct SymbolEdit  { id, file, kind, start, end, new_name }  (line 67)
  struct FileRename  { from, to, is_directory_move, old_module_id, new_module_id }  (line 77)

rename/core/mod_decls.rs:
  fn update_mod_declarations(
    project: &Path,
    table: &SymbolIndex,
    file_renames: &[FileRename],
    touched_files: &mut HashSet<PathBuf>,
) -> Result<()>  (line 11)
  fn resolve_renamed_path(path: PathBuf, lookup: &HashMap<String, PathBuf>) -> PathBuf  (line 165)
  fn resolve_parent_definition_file(
    project: &Path,
    table: &SymbolIndex,
    parent_id: &str,
    rename_lookup: &HashMap<String, PathBuf>,
) -> Option<PathBuf>  (line 170)
  fn find_crate_root_file(project: &Path) -> Option<PathBuf>  (line 190)
  struct ModuleRenamePlan  { old_name, new_name, old_parent, new_parent }  (line 203)

rename/core/alias.rs:
  fn collect_and_rename_aliases(
    project: &Path,
    symbol_table: &SymbolIndex,
    mapping: &HashMap<String, String>,
) -> Result<Vec<SymbolEdit>>  (line 14)
  fn collect_alias_edits(
    tree: &syn::UseTree,
    has_leading_colon: bool,
    module_path: &str,
    file: &Path,
    symbol_table: &SymbolIndex,
    mapping: &HashMap<String, String>,
    edits: &mut Vec<SymbolEdit>,
)  (line 47)
  fn collect_alias_edits_recursive(
    tree: &syn::UseTree,
    prefix: &mut Vec<String>,
    module_path: &str,
    file: &Path,
    symbol_table: &SymbolIndex,
    mapping: &HashMap<String, String>,
    edits: &mut Vec<SymbolEdit>,
)  (line 72)
  fn collect_alias_usage_edits(
    file: &Path,
    alias_name: &str,
    new_alias: &str,
    target_id: &str,
    edits: &mut Vec<SymbolEdit>,
)  (line 150)
  struct AliasUsageVisitor  { alias_name, new_alias, target_id, file, edits }  (line 172)
  impl Visit<'ast> for AliasUsageVisitor<'_>  { fn visit_path(&mut self, path: &'ast syn::Path) }  (line 180)

rename/core/structured.rs:
  struct StructuredEditTracker  { files, doc_files, attr_files, use_files }  (line 17)
  impl StructuredEditTracker  { fn new() -> Self, fn mark_doc_edit(&mut self, file: String), fn mark_attr_edit(&mut self, file: String), fn mark_use_edit(&mut self, file: String), fn mark_generic(&mut self, file: String), fn all_files(&self) -> &HashSet<String>, fn into_set(self) -> HashSet<String>, fn doc_files(&self) -> &HashSet<String>, fn attr_files(&self) -> &HashSet<String>, fn use_files(&self) -> &HashSet<String>, fn summary(&self, config: &StructuredEditOptions) -> String }  (line 23)

rename/core/format.rs:
  fn format_files(paths: &[PathBuf]) -> Result<Vec<String>>  (line 9)

rename/core/cli.rs:
  fn run_names(args: &[String]) -> Result<()>  (line 7)
  fn run_rename(args: &[String]) -> Result<()>  (line 29)

rename/core/preview.rs:
  fn write_preview(
    out: &Path,
    edits: &[SymbolEdit],
    renames: &[FileRename],
    structured_tracker: &StructuredEditTracker,
    config: &StructuredEditOptions,
) -> Result<()>  (line 8)

rename/core/project_editor/mod.rs:
  struct EditConflict  { symbol_id, reason }  (line 19)
  struct ChangeReport  { touched_files, conflicts }  (line 25)
  struct ProjectEditor  { registry, changesets, oracle }  (line 30)
  struct QueuedOp  { symbol_id, op }  (line 37)
  impl ProjectEditor  { fn load(project: &Path, oracle: Box<dyn StructuralEditOracle>) -> Result<Self>, fn load_with_rustc(project: &Path) -> Result<Self>, fn queue(&mut self, symbol_id: &str, op: NodeOp) -> Result<()>, fn queue_by_id(&mut self, symbol_id: &str, mutation: FieldMutation) -> Result<()>, fn apply(&mut self) -> Result<ChangeReport>, fn validate(&self) -> Result<Vec<EditConflict>>, fn commit(&self) -> Result<Vec<PathBuf>>, fn preview(&self) -> Result<String> }  (line 42)
  struct NodeRegistryBuilder  { project_root, file, registry, module_path, item_index, parent_path, current_impl }  (line 211)
  impl NodeRegistryBuilder<'a>  { fn new(project_root: &'a Path, file: &'a Path, registry: &'a mut NodeRegistry) -> Self, fn register(&mut self, ident: &syn::Ident, kind: NodeKind), fn register_with_id(&mut self, id: String, kind: NodeKind), fn register_use_tree(&mut self, tree: &syn::UseTree) }  (line 221)
  impl syn::visit::Visit<'ast> for NodeRegistryBuilder<'_>  { fn visit_file(&mut self, i: &'ast syn::File), fn visit_item_fn(&mut self, i: &'ast syn::ItemFn), fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct), fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum), fn visit_item_trait(&mut self, i: &'ast syn::ItemTrait), fn visit_item_type(&mut self, i: &'ast syn::ItemType), fn visit_item_const(&mut self, i: &'ast syn::ItemConst), fn visit_item_mod(&mut self, i: &'ast syn::ItemMod), fn visit_item_use(&mut self, i: &'ast syn::ItemUse), fn visit_item_impl(&mut self, i: &'ast syn::ItemImpl), fn visit_impl_item_fn(&mut self, i: &'ast syn::ImplItemFn) }  (line 271)
  struct ImplContext  { struct_path, trait_path }  (line 366)

rename/core/project_editor/ops.rs:
  fn apply_node_op(
    ast: &mut syn::File,
    handles: &HashMap<String, NodeHandle>,
    symbol_id: &str,
    op: &NodeOp,
) -> Result<()>  (line 9)
  fn apply_field_mutation(
    ast: &mut syn::File,
    handle: &NodeHandle,
    symbol_id: &str,
    mutation: &FieldMutation,
) -> Result<()>  (line 33)
  fn rename_ident(ast: &mut syn::File, handle: &NodeHandle, symbol_id: &str, new_name: &str) -> bool  (line 106)
  fn replace_node(ast: &mut syn::File, handle: &NodeHandle, new_node: syn::Item) -> Result<()>  (line 123)
  fn insert_node(
    ast: &mut syn::File,
    handle: &NodeHandle,
    new_node: syn::Item,
    before: bool,
) -> Result<()>  (line 135)
  fn delete_node(ast: &mut syn::File, handle: &NodeHandle) -> Result<()>  (line 155)
  fn reorder_items(
    ast: &mut syn::File,
    handles: &HashMap<String, NodeHandle>,
    new_order: &[String],
) -> Result<()>  (line 166)
  fn change_visibility(
    ast: &mut syn::File,
    handle: &NodeHandle,
    symbol_id: &str,
    new_vis: &syn::Visibility,
) -> bool  (line 216)
  fn add_attribute(
    ast: &mut syn::File,
    handle: &NodeHandle,
    symbol_id: &str,
    attr: syn::Attribute,
) -> bool  (line 267)
  fn remove_attribute(
    ast: &mut syn::File,
    handle: &NodeHandle,
    symbol_id: &str,
    name: &str,
) -> bool  (line 293)
  fn replace_signature(
    ast: &mut syn::File,
    handle: &NodeHandle,
    symbol_id: &str,
    sig: syn::Signature,
) -> bool  (line 358)
  fn add_struct_field(
    ast: &mut syn::File,
    handle: &NodeHandle,
    _symbol_id: &str,
    field: syn::Field,
) -> bool  (line 381)
  fn remove_struct_field(
    ast: &mut syn::File,
    handle: &NodeHandle,
    _symbol_id: &str,
    name: &str,
) -> bool  (line 405)
  fn add_variant(
    ast: &mut syn::File,
    handle: &NodeHandle,
    _symbol_id: &str,
    variant: syn::Variant,
) -> bool  (line 433)
  fn remove_variant(
    ast: &mut syn::File,
    handle: &NodeHandle,
    _symbol_id: &str,
    name: &str,
) -> bool  (line 448)
  enum TargetItemMut  { Top, ImplFn }  (line 469)
  fn resolve_target_mut(
    ast: &'a mut syn::File,
    handle: &NodeHandle,
    symbol_id: &str,
) -> Option<TargetItemMut<'a>>  (line 474)
  fn rename_ident_in_item(item: &mut syn::Item, target: &str, new_name: &str) -> bool  (line 501)
  fn split_impl_path(handle: &NodeHandle) -> Option<(&[usize], usize)>  (line 550)
  fn get_item_mut(
    items: &'a mut Vec<syn::Item>,
    module_path: &[usize],
    item_index: usize,
) -> Option<&'a mut syn::Item>  (line 559)
  fn resolve_items_container_mut(
    ast: &'a mut syn::File,
    module_path: &[usize],
) -> Option<&'a mut Vec<syn::Item>>  (line 576)
  fn resolve_items_container_from(
    items: &'a mut Vec<syn::Item>,
    module_path: &[usize],
) -> Option<&'a mut Vec<syn::Item>>  (line 583)

rename/core/project_editor/propagate.rs:
  struct PropagationResult  { rewrites, conflicts }  (line 22)
  fn propagate(
    op: &NodeOp,
    symbol_id: &str,
    registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 27)
  fn propagate_rename(
    symbol_id: &str,
    new_name: &str,
    registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 74)
  fn propagate_delete(
    symbol_id: &str,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 116)
  fn propagate_remove_field(
    symbol_id: &str,
    field_name: &str,
    _registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 142)
  fn propagate_remove_variant(
    symbol_id: &str,
    variant_name: &str,
    _registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 162)
  fn propagate_visibility(
    symbol_id: &str,
    _new_vis: &syn::Visibility,
    registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 182)
  fn propagate_signature(
    symbol_id: &str,
    new_sig: &syn::Signature,
    _registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 209)
  fn propagate_add_field(
    symbol_id: &str,
    field: &syn::Field,
    _registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 231)
  fn propagate_add_variant(
    symbol_id: &str,
    variant: &syn::Variant,
    _registry: &NodeRegistry,
    oracle: &dyn StructuralEditOracle,
) -> Result<PropagationResult>  (line 256)
  fn occurrence_to_edit(occ: &SymbolOccurrence, new_name: &str) -> SymbolEdit  (line 277)
  fn build_symbol_index_and_occurrences(
    registry: &NodeRegistry,
) -> Result<(SymbolIndex, Vec<SymbolOccurrence>, AliasGraph)>  (line 288)
  fn build_visibility_map(
    registry: &NodeRegistry,
    _alias_graph: &AliasGraph,
) -> Result<HashMap<String, VisibilityScope>>  (line 332)
  fn leak_conflicts(analysis: &VisibilityLeakAnalysis) -> Vec<EditConflict>  (line 366)
  fn find_project_root(registry: &NodeRegistry) -> Result<PathBuf>  (line 377)
  fn apply_rewrites(
    registry: &mut NodeRegistry,
    rewrites: &[SymbolEdit],
) -> Result<HashSet<PathBuf>>  (line 395)

rename/core/collect/mod.rs:
  fn collect_names(project: &Path) -> Result<SymbolIndexReport>  (line 21)
  fn emit_names(project: &Path, out: &Path) -> Result<()>  (line 129)
  fn update_symbol_snapshot(out: &mut Vec<SymbolRecord>, id: &str, mut update: F)  (line 138)
  fn merge_symbol_metadata(target: &mut SymbolRecord, source: &SymbolRecord)  (line 147)
  fn add_file_module_symbol(
    module_path: &str,
    file: &Path,
    symbol_table: &mut SymbolIndex,
    out: &mut Vec<SymbolRecord>,
    symbol_set: &mut HashSet<String>,
)  (line 168)
  fn stub_range() -> SpanRange  (line 216)
  fn collect_symbols(
    ast: &syn::File,
    module_path: &str,
    file: &Path,
    symbol_table: &mut SymbolIndex,
    out: &mut Vec<SymbolRecord>,
    symbol_set: &mut HashSet<String>,
) -> AliasGraph  (line 223)

rename/core/collect/collector.rs:
  struct SymbolCollector  { module_path, file, symbols, current_impl, alias_graph }  (line 13)
  struct ImplContext  { struct_path, trait_path }  (line 22)
  impl SymbolCollector<'a>  { fn new(
        module_path: &'a str,
        file: &'a Path,
        alias_graph: &'a mut crate::rename::alias::AliasGraph,
    ) -> Self, fn into_symbols(self) -> Vec<SymbolRecord>, fn add_symbol(
        &mut self,
        id: String,
        kind: &str,
        name: &str,
        span: Span,
        docs: Vec<String>,
        attrs: Vec<String>,
    ), fn extract_docs_and_attrs(attrs: &[syn::Attribute]) -> (Vec<String>, Vec<String>), fn collect_use_tree_root(
        &mut self,
        tree: &syn::UseTree,
        docs: &[String],
        attrs: &[String],
        visibility: VisibilityScope,
    ), fn collect_use_tree_with_prefix(
        &mut self,
        tree: &syn::UseTree,
        prefix: String,
        docs: &[String],
        attrs: &[String],
        visibility: VisibilityScope,
    ) }  (line 27)
  impl Visit<'ast> for SymbolCollector<'_>  { fn visit_item_mod(&mut self, i: &'ast syn::ItemMod), fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct), fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum), fn visit_item_trait(&mut self, i: &'ast syn::ItemTrait), fn visit_item_fn(&mut self, i: &'ast syn::ItemFn), fn visit_item_type(&mut self, i: &'ast syn::ItemType), fn visit_item_const(&mut self, i: &'ast syn::ItemConst), fn visit_item_static(&mut self, i: &'ast syn::ItemStatic), fn visit_item_macro(&mut self, i: &'ast syn::ItemMacro), fn visit_item_use(&mut self, i: &'ast syn::ItemUse), fn visit_item_impl(&mut self, i: &'ast syn::ItemImpl), fn visit_impl_item_fn(&mut self, i: &'ast syn::ImplItemFn) }  (line 233)

rename/core/symbol_id.rs:
  fn normalize_symbol_id(raw: &str) -> String  (line 1)
  fn normalize_symbol_id_with_crate(raw: &str, crate_name: Option<&str>) -> String  (line 5)
  fn strip_hash_suffix(segment: &str) -> &str  (line 50)

rename/core/use_map.rs:
  fn build_use_map(ast: &syn::File, module_path: &str) -> HashMap<String, String>  (line 2)
  fn use_tree_to_map(
    tree: &syn::UseTree,
    prefix: &mut Vec<String>,
    module_path: &str,
    map: &mut HashMap<String, String>,
)  (line 15)
  fn normalize_use_prefix(prefix: &[String], module_path: &str) -> Vec<String>  (line 46)
  fn resolve_relative_prefix(prefix: &[String], module_path: &str) -> Vec<String>  (line 60)
  fn path_to_string(path: &syn::Path, module_path: &str) -> String  (line 77)
  fn type_path_string(ty: &syn::Type, module_path: &str) -> String  (line 91)

rename/core/span.rs:
  fn span_to_range(span: Span) -> SpanRange  (line 5)
  fn span_to_offsets(
    content: &str,
    start: &LineColumn,
    end: &LineColumn,
) -> (usize, usize)  (line 20)

rename/core/paths.rs:
  fn plan_file_renames(
    table: &SymbolIndex,
    mapping: &HashMap<String, String>,
) -> Result<Vec<FileRename>>  (line 7)
  fn compute_new_file_path(
    old_file: &str,
    _old_module_id: &str,
    new_module_path: &str,
) -> Result<Option<String>>  (line 132)
  fn module_path_for_file(project: &Path, file: &Path) -> String  (line 203)
  fn module_child_path(module_path: &str, child: String) -> String  (line 231)

rename/core/oracle.rs:
  trait StructuralEditOracle  (line 4)
  struct NullOracle  (line 13)
  impl StructuralEditOracle for NullOracle  { fn impact_of(&self, _symbol_id: &str) -> Vec<String>, fn satisfies_bounds(&self, _id: &str, _new_sig: &Signature) -> bool, fn is_macro_generated(&self, _symbol_id: &str) -> bool, fn cross_crate_users(&self, _symbol_id: &str) -> Vec<String> }  (line 15)

rename/occurrence.rs:
  struct EnhancedOccurrenceVisitor  { module_path, file, symbol_table, use_map, occurrences, scoped_binder, current_impl, current_struct }  (line 14)
  struct ImplContext  { type_name }  (line 25)
  impl EnhancedOccurrenceVisitor<'a>  { fn new(
        module_path: &'a str,
        file: &'a Path,
        symbol_table: &'a SymbolIndex,
        use_map: &'a HashMap<String, String>,
        occurrences: &'a mut Vec<SymbolOccurrence>,
    ) -> Self, fn add_occurrence(&mut self, id: String, kind: &str, span: Span), fn process_pattern_bindings(&mut self, pat: &Pat), fn infer_expr_type(&self, expr: &Expr) -> Option<String> }  (line 28)
  impl Visit<'a> for EnhancedOccurrenceVisitor<'a>  { fn visit_item_struct(&mut self, node: &'a syn::ItemStruct), fn visit_item_enum(&mut self, node: &'a syn::ItemEnum), fn visit_item_fn(&mut self, node: &'a syn::ItemFn), fn visit_item_impl(&mut self, node: &'a ItemImpl), fn visit_impl_item_fn(&mut self, node: &'a ImplItemFn), fn visit_local(&mut self, node: &'a Local), fn visit_arm(&mut self, node: &'a Arm), fn visit_expr_for_loop(&mut self, node: &'a ExprForLoop), fn visit_expr_closure(&mut self, node: &'a ExprClosure), fn visit_expr_method_call(&mut self, node: &'a ExprMethodCall), fn visit_path(&mut self, path: &'a syn::Path), fn visit_item_use(&mut self, node: &'a syn::ItemUse), fn visit_item_macro(&mut self, node: &'a ItemMacro) }  (line 120)
  fn normalize_use_prefix(prefix: &[String], module_path: &str) -> Vec<String>  (line 282)
  fn resolve_relative_prefix(prefix: &[String], module_path: &str) -> Vec<String>  (line 295)
  fn path_to_string(path: &syn::Path) -> String  (line 310)
  fn path_to_symbol(
    path: &syn::Path,
    module_path: &str,
    use_map: &HashMap<String, String>,
    symbol_table: &SymbolIndex,
) -> Option<String>  (line 317)
  impl EnhancedOccurrenceVisitor<'a>  { fn resolve_symbol(&self, symbol: &str) -> Option<String>, fn record_use_tree(&mut self, tree: &syn::UseTree, prefix: &mut Vec<String>) }  (line 333)

rename/pattern.rs:
  struct PatternBindingCollector  { bindings }  (line 7)
  impl PatternBindingCollector  { fn new() -> Self, fn collect_from_pattern(pat: &Pat) -> Vec<(String, Option<String>)> }  (line 12)
  impl Visit<'ast> for PatternBindingCollector  { fn visit_pat_ident(&mut self, node: &'ast PatIdent), fn visit_pat_tuple(&mut self, node: &'ast PatTuple), fn visit_pat_struct(&mut self, node: &'ast PatStruct), fn visit_pat_tuple_struct(&mut self, node: &'ast PatTupleStruct), fn visit_pat_slice(&mut self, node: &'ast PatSlice) }  (line 27)
  fn extract_type_from_pattern(pat: &Pat) -> Option<String>  (line 76)
  fn type_to_string(ty: &syn::Type) -> String  (line 87)
  fn path_to_string(path: &syn::Path) -> String  (line 105)

rename/api.rs:
  struct QueryRequest  { kinds, module_prefix, name_contains }  (line 17)
  impl Default for QueryRequest  { fn default() -> Self }  (line 28)
  struct QueryResult  { report, matches }  (line 39)
  impl QueryRequest  { fn new() -> Self, fn kind(mut self, kind: impl Into<String>) -> Self, fn module_prefix(mut self, prefix: impl Into<String>) -> Self, fn name_contains(mut self, needle: impl Into<String>) -> Self, fn execute(&self, project: &Path) -> Result<QueryResult>, fn matches_symbol(&self, symbol: &SymbolRecord) -> bool }  (line 45)
  struct MutationRequest  { renames, dry_run, preview_path }  (line 96)
  struct MutationResult  { renamed, dry_run, preview_path }  (line 109)
  impl MutationRequest  { fn new() -> Self, fn rename(mut self, id: impl Into<String>, new_name: impl Into<String>) -> Self, fn extend(mut self, entries: I) -> Self, fn dry_run(mut self, dry_run: bool) -> Self, fn preview_path(mut self, path: impl Into<PathBuf>) -> Self, fn execute(self, project: &Path) -> Result<MutationResult> }  (line 114)
  struct UpsertRequest  { edits, node_ops, format }  (line 162)
  struct UpsertResult  { touched_files }  (line 175)
  impl UpsertRequest  { fn new() -> Self, fn edit(mut self, edit: AstEdit) -> Self, fn push_node_op(mut self, op: NodeOp) -> Self, fn format(mut self, enabled: bool) -> Self, fn execute(self) -> Result<UpsertResult> }  (line 178)
  fn default_true() -> bool  (line 213)
  fn execute_query_json(project: &Path, payload: &str) -> Result<String>  (line 217)
  fn execute_mutation_json(project: &Path, payload: &str) -> Result<String>  (line 223)
  fn execute_upsert_json(payload: &str) -> Result<String>  (line 229)

rename/macros.rs:
  fn extract_macro_rules_identifiers(item_macro: &ItemMacro) -> Vec<(String, Span)>  (line 6)
  fn extract_identifiers_from_tokens(
    tokens: &TokenStream,
    identifiers: &mut Vec<(String, Span)>,
)  (line 15)
  fn is_macro_keyword(ident: &str) -> bool  (line 35)
  fn is_metavariable(ident: &str) -> bool  (line 42)
  fn extract_derive_idents(meta_list: &syn::MetaList) -> Vec<(String, Span)>  (line 46)
  fn extract_proc_macro_idents(meta_list: &syn::MetaList) -> Vec<(String, Span)>  (line 53)
  struct MacroInvocationAnalyzer  { patterns }  (line 63)
  struct MacroPattern  { macro_name, predict }  (line 67)
  impl MacroInvocationAnalyzer  { fn new() -> Self, fn predict_generated_idents(
        &self,
        macro_name: &str,
        tokens: &TokenStream,
    ) -> Vec<String> }  (line 72)
  fn is_unsupported_macro(macro_path: &syn::Path) -> bool  (line 90)
  struct MacroHandlingReport  { supported_macros, unsupported_macros, extracted_identifiers, flagged_for_review }  (line 103)
  impl MacroHandlingReport  { fn new() -> Self, fn add_unsupported(&mut self, macro_name: String), fn add_flagged_reason(&mut self, reason: String) }  (line 109)
  struct MacroIdentifierCollector  { identifiers, report }  (line 126)
  impl MacroIdentifierCollector  { fn new() -> Self, fn process_macro_rules_def(&mut self, item_macro: &ItemMacro), fn process_macro_invocation(&mut self, mac: &syn::Macro) }  (line 130)

rename/alias/visibility.rs:
  impl AliasGraph  { fn analyze_visibility_leaks(
        &self,
        symbols: &HashMap<String, VisibilityScope>,
    ) -> VisibilityLeakAnalysis, fn detect_visibility_leak(
        &self,
        symbol_id: &str,
        original_visibility: &VisibilityScope,
        origin_module: &str,
        leaked: &mut Vec<LeakedSymbol>,
    ), fn detect_visibility_leak_recursive(
        &self,
        current_path: &str,
        original_visibility: &VisibilityScope,
        origin_module: &str,
        chain: Vec<String>,
        leaked: &mut Vec<LeakedSymbol>,
    ) }  (line 7)

rename/alias/types.rs:
  struct ImportNode  { id, module_path, source_path, local_name, original_name, kind, visibility, file }  (line 7)
  enum UseKind  { Simple, Aliased, Glob, ReExport, ReExportAliased }  (line 34)
  enum VisibilityScope  { Public, Crate, Super, Private, Restricted }  (line 52)
  impl From<&Visibility> for VisibilityScope  { fn from(vis: &Visibility) -> Self }  (line 69)
  struct AliasEdge  { from, to, kind }  (line 99)
  enum EdgeKind  { Import, ReExport, Alias, Transitive }  (line 111)
  struct ResolutionChain  { start_name, start_module, steps, resolved_symbol }  (line 127)
  struct ResolutionStep  { kind, name, module, use_node_id }  (line 142)
  enum StepKind  { Start, LocalUse, ReExport, GlobImport, DirectLookup }  (line 157)
  struct VisibilityLeakAnalysis  { public_symbols, restricted_symbols, leaked_private_symbols }  (line 176)
  struct ExposurePath  { origin_module, reexport_chain, visibility }  (line 190)
  struct LeakedSymbol  { symbol_id, original_visibility, leaked_to, leak_chain }  (line 203)

rename/alias/graph.rs:
  struct AliasGraph  { nodes, local_names, source_imports, glob_imports, edges }  (line 9)
  impl AliasGraph  { fn new() -> Self, fn add_use_node(&mut self, node: ImportNode), fn resolve_local(&self, module_path: &str, local_name: &str) -> Option<&str>, fn get_importers(&self, source_path: &str) -> Vec<&ImportNode>, fn get_glob_imports(&self, module_path: &str) -> Vec<&ImportNode>, fn is_visible(
        &self,
        symbol_module: &str,
        from_module: &str,
        visibility: &VisibilityScope,
    ) -> bool, fn all_nodes(&self) -> Vec<&ImportNode>, fn nodes_in_file(&self, file_path: &str) -> Vec<&ImportNode>, fn add_edge(&mut self, from: String, to: String, kind: EdgeKind), fn build_edges(&mut self), fn resolve_alias_chain(&self, module_path: &str, name: &str) -> ResolutionChain, fn follow_reexport_chain(&self, chain: &mut ResolutionChain, current_path: &str), fn resolve_through_glob(&self, module_path: &str, name: &str) -> Option<String>, fn all_edges(&self) -> &[AliasEdge], fn find_reexport_chains(&self, symbol_id: &str) -> Vec<Vec<ImportNode>>, fn find_reexport_chains_recursive(
        &self,
        symbol_id: &str,
        current_chains: &mut Vec<Vec<ImportNode>>,
        result: &mut Vec<Vec<ImportNode>>,
    ) }  (line 24)

rename/alias/helpers.rs:
  fn extract_module_from_path(path: &str) -> String  (line 1)


