use std::collections::HashMap;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use syn::visit::Visit;

use crate::fs;
use crate::rename::core::oracle::StructuralEditOracle;
use crate::rename::core::symbol_id::normalize_symbol_id;
use crate::rename::structured::{NodeOp, node_handle};
use crate::state::{NodeRegistry, NodeKind};

#[derive(Debug, Clone)]
pub struct EditConflict {
    pub symbol_id: String,
    pub reason: String,
}

#[derive(Debug, Clone)]
pub struct ChangeReport {
    pub touched_files: Vec<PathBuf>,
}

pub struct ProjectEditor {
    pub registry: NodeRegistry,
    pub changesets: HashMap<PathBuf, Vec<NodeOp>>,
    pub oracle: Box<dyn StructuralEditOracle>,
}

impl ProjectEditor {
    pub fn load(project: &Path, oracle: Box<dyn StructuralEditOracle>) -> Result<Self> {
        let files = fs::collect_rs_files(project)?;
        let mut registry = NodeRegistry::new();

        for file in files {
            let content = std::fs::read_to_string(&file)?;
            let ast = syn::parse_file(&content)
                .with_context(|| format!("Failed to parse {}", file.display()))?;
            let mut builder = NodeRegistryBuilder::new(&file, &mut registry);
            builder.visit_file(&ast);
            registry.insert_ast(file, ast);
        }

        Ok(Self {
            registry,
            changesets: HashMap::new(),
            oracle,
        })
    }

    pub fn queue(&mut self, symbol_id: &str, op: NodeOp) -> Result<()> {
        let norm = normalize_symbol_id(symbol_id);
        let handle = match &op {
            NodeOp::ReplaceNode { handle, .. }
            | NodeOp::InsertBefore { handle, .. }
            | NodeOp::InsertAfter { handle, .. }
            | NodeOp::DeleteNode { handle }
            | NodeOp::MutateField { handle, .. } => Some(handle),
            NodeOp::ReorderItems { .. } => None,
        };

        if let Some(handle) = handle {
            let exists = self.registry.handles.get(&norm);
            if exists.is_none() {
                self.registry.insert_handle(norm.clone(), handle.clone());
            }
        }

        let file = match &op {
            NodeOp::ReplaceNode { handle, .. }
            | NodeOp::InsertBefore { handle, .. }
            | NodeOp::InsertAfter { handle, .. }
            | NodeOp::DeleteNode { handle }
            | NodeOp::MutateField { handle, .. } => handle.file.clone(),
            NodeOp::ReorderItems { file, .. } => file.clone(),
        };

        self.changesets.entry(file).or_default().push(op);
        Ok(())
    }

    pub fn apply(&mut self) -> Result<ChangeReport> {
        let touched_files = self.changesets.keys().cloned().collect::<Vec<_>>();
        Ok(ChangeReport { touched_files })
    }

    pub fn validate(&self) -> Result<Vec<EditConflict>> {
        let mut conflicts = Vec::new();
        for (symbol_id, _handle) in &self.registry.handles {
            if self.oracle.is_macro_generated(symbol_id) {
                conflicts.push(EditConflict {
                    symbol_id: symbol_id.clone(),
                    reason: "symbol generated by macro".to_string(),
                });
            }
        }
        Ok(conflicts)
    }

    pub fn commit(&self) -> Result<Vec<PathBuf>> {
        Ok(self.changesets.keys().cloned().collect())
    }

    pub fn preview(&self) -> Result<String> {
        Ok(format!("{} files touched", self.changesets.len()))
    }
}

struct NodeRegistryBuilder<'a> {
    file: &'a Path,
    registry: &'a mut NodeRegistry,
    item_index: usize,
    parent_path: Vec<usize>,
}

impl<'a> NodeRegistryBuilder<'a> {
    fn new(file: &'a Path, registry: &'a mut NodeRegistry) -> Self {
        Self {
            file,
            registry,
            item_index: 0,
            parent_path: Vec::new(),
        }
    }

    fn register(&mut self, ident: &syn::Ident, kind: NodeKind) {
        let handle = node_handle(
            self.file,
            self.item_index,
            self.parent_path.clone(),
            kind,
        );
        self.registry
            .insert_handle(normalize_symbol_id(&format!("crate::{}", ident)), handle);
    }

    fn register_use_tree(&mut self, tree: &syn::UseTree) {
        match tree {
            syn::UseTree::Name(name) => self.register(&name.ident, NodeKind::Use),
            syn::UseTree::Rename(rename) => self.register(&rename.rename, NodeKind::Use),
            syn::UseTree::Path(path) => self.register_use_tree(&path.tree),
            syn::UseTree::Group(group) => {
                for item in &group.items {
                    self.register_use_tree(item);
                }
            }
            syn::UseTree::Glob(_) => {}
        }
    }
}

impl<'ast> syn::visit::Visit<'ast> for NodeRegistryBuilder<'_> {
    fn visit_file(&mut self, i: &'ast syn::File) {
        for (idx, item) in i.items.iter().enumerate() {
            self.item_index = idx;
            self.visit_item(item);
        }
    }

    fn visit_item_fn(&mut self, i: &'ast syn::ItemFn) {
        self.register(&i.sig.ident, NodeKind::Fn);
        syn::visit::visit_item_fn(self, i);
    }

    fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct) {
        self.register(&i.ident, NodeKind::Struct);
        syn::visit::visit_item_struct(self, i);
    }

    fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum) {
        self.register(&i.ident, NodeKind::Enum);
        syn::visit::visit_item_enum(self, i);
    }

    fn visit_item_trait(&mut self, i: &'ast syn::ItemTrait) {
        self.register(&i.ident, NodeKind::Trait);
        syn::visit::visit_item_trait(self, i);
    }

    fn visit_item_type(&mut self, i: &'ast syn::ItemType) {
        self.register(&i.ident, NodeKind::Type);
        syn::visit::visit_item_type(self, i);
    }

    fn visit_item_const(&mut self, i: &'ast syn::ItemConst) {
        self.register(&i.ident, NodeKind::Const);
        syn::visit::visit_item_const(self, i);
    }

    fn visit_item_mod(&mut self, i: &'ast syn::ItemMod) {
        self.register(&i.ident, NodeKind::Mod);
        syn::visit::visit_item_mod(self, i);
    }

    fn visit_item_use(&mut self, i: &'ast syn::ItemUse) {
        self.register_use_tree(&i.tree);
        syn::visit::visit_item_use(self, i);
    }

    fn visit_item_impl(&mut self, i: &'ast syn::ItemImpl) {
        let impl_index = self.item_index;
        self.parent_path.push(impl_index);
        syn::visit::visit_item_impl(self, i);
        self.parent_path.pop();
    }

    fn visit_impl_item_fn(&mut self, i: &'ast syn::ImplItemFn) {
        self.register(&i.sig.ident, NodeKind::ImplFn);
        syn::visit::visit_impl_item_fn(self, i);
    }
}
