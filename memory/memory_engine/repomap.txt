page/page_impl.rs:
  impl std::fmt::Debug for Page  { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result }  (line 6)
  struct Page  { id, epoch, data, location }  (line 17)
  impl Page  { fn new(id: PageID, size: usize, location: PageLocation) -> Result<Self, PageError> }  (line 24)
  impl PageAccess for Page  { fn location(&self) -> PageLocation, fn epoch(&self) -> Epoch, fn set_epoch(&self, epoch: Epoch), fn data_slice(&self) -> &[u8], fn data_mut_slice(&mut self) -> &mut [u8] }  (line 39)
  impl DeltaAppliable for Page  { fn apply_delta(&mut self, delta: &Delta) -> Result<(), PageError> }  (line 60)

page/allocator_impl.rs:
  struct PageAllocator  { pages, default_location }  (line 7)
  impl PageAllocator  { fn new(default_location: PageLocation) -> Self, fn from_config(config: PageAllocatorConfig) -> Self, fn with_page(&self, id: PageID, f: F) -> Option<R>, fn with_page_mut(&self, id: PageID, f: F) -> Option<R>, fn snapshot(&self, id: PageID) -> Option<PageSnapshotData>, fn restore(&self, snapshot: &PageSnapshotData) -> Result<(), PageError>, fn snapshot_pages(&self) -> Vec<PageSnapshotData>, fn page_infos(&self) -> Vec<PageSnapshotData> }  (line 12)
  impl PageAllocatorLike for PageAllocator  { fn allocate(&self, id: PageID, size: usize) -> Result<(), PageError> }  (line 79)

page/types.rs:
  enum PageLocation  { Cpu, Gpu, Unified }  (line 5)
  impl PageLocation  { fn from_tag(tag: i32) -> Result<Self, PageError> }  (line 11)
  enum PageError  { InvalidSize, InvalidLocation, MaskSizeMismatch, PageIDMismatch, AllocationFailed, MetadataDecode, PageNotFound }  (line 23)
  struct PageAllocatorConfig  { default_location, initial_capacity }  (line 48)
  impl Default for PageAllocatorConfig  { fn default() -> Self }  (line 53)
  struct PageSnapshotData  { page_id, data, location, epoch }  (line 64)

page/allocator_trait.rs:
  trait PageAllocatorLike  (line 4)

page/traits.rs:
  trait PageAccess  (line 6)
  trait DeltaAppliable  (line 17)

memory_engine.rs:
  struct MemoryEngineConfig  { tlog_path }  (line 42)
  enum MemoryEngineError  { TlogOpen, GraphLogOpen, GraphLogIo, Admission, Commit, DeltaNotFound }  (line 51)
  enum AdmissionError  { InvalidJudgmentProof, StaleEpoch, AlreadyAdmitted }  (line 72)
  enum CommitError  { TlogWrite }  (line 84)
  struct MemoryEngine  { wal, epoch, admitted, deltas, state }  (line 92)
  impl MemoryEngine  { fn new(config: MemoryEngineConfig) -> Result<Self, MemoryEngineError>, fn checkpoint(&self, path: P) -> std::io::Result<()>, fn current_root_hash(&self) -> Hash, fn compact(&self) -> std::io::Result<()>, fn admit_execution(
        &self,
        judgment_proof: &JudgmentProof,
    ) -> Result<AdmissionProof, AdmissionError>, fn record_outcome(&self, commit: &CommitProof) -> OutcomeProof, fn register_delta(&self, delta: Delta) -> Hash, fn fetch_delta_by_hash(&self, hash: &Hash) -> Option<Delta>, fn commit_batch(
        &self,
        admission: &AdmissionProof,
        delta_hashes: &[Hash],
    ) -> Result<Vec<CommitProof>, MemoryEngineError>, fn compute_event_hash(
        &self,
        admission: &AdmissionProof,
        commit: &CommitProof,
        outcome: &OutcomeProof,
    ) -> Hash, fn commit_graph_delta(&self, delta: GraphDelta) -> Result<(), MemoryEngineError>, fn materialized_graph(&self) -> Result<GraphSnapshot, MemoryEngineError>, fn verify_judgment_proof(&self, proof: &JudgmentProof) -> bool, fn hash_delta(delta: &Delta) -> Hash }  (line 100)
  impl Engine for MemoryEngine  { fn admit_execution(
        &self,
        judgment_proof: &JudgmentProof,
    ) -> Result<AdmissionProof, Self::Error>, fn register_delta(&self, delta: Delta) -> Hash, fn fetch_delta_by_hash(&self, hash: &Hash) -> Option<Delta>, fn commit_delta(
        &self,
        admission: &AdmissionProof,
        delta_hash: &Hash,
    ) -> Result<CommitProof, Self::Error>, fn commit_batch(
        &self,
        admission: &AdmissionProof,
        delta_hashes: &[Hash],
    ) -> Result<Vec<CommitProof>, Self::Error>, fn record_outcome(&self, commit: &CommitProof) -> OutcomeProof, fn compute_event_hash(
        &self,
        admission: &AdmissionProof,
        commit: &CommitProof,
        outcome: &OutcomeProof,
    ) -> Hash, fn commit_graph_delta(&self, delta: GraphDelta) -> Result<(), Self::Error>, fn materialized_graph(&self) -> Result<GraphSnapshot, Self::Error> }  (line 394)

graph_log.rs:
  struct GraphDelta  { payload }  (line 5)
  struct GraphSnapshot  { payload }  (line 11)
  enum GraphDeltaError  { Materialization }  (line 17)

canonical_state.rs:
  struct MerkleState  { root_hash, page_store, device_tree_ptr, device_tree_bytes, max_leaves, tree_size, backend }  (line 6)
  impl Send for MerkleState  (line 20)
  impl Sync for MerkleState  (line 21)
  impl Drop for MerkleState  { fn drop(&mut self) }  (line 23)
  impl MerkleState  { fn new_empty(backend: Box<dyn HashBackend>) -> Self, fn with_capacity(max_leaves: u64, backend: Box<dyn HashBackend>) -> Self, fn apply_delta(&mut self, delta: &crate::delta::Delta) -> Result<(), DeltaError>, fn apply_deltas_batch(&mut self, deltas: &[crate::delta::Delta]) -> Result<(), DeltaError>, fn root_hash(&self) -> Hash, fn read_page(&self, page_id: u64) -> &[u8], fn checkpoint(&self, path: P) -> std::io::Result<()>, fn restore_from_checkpoint(
        path: P,
        backend: Box<dyn HashBackend>,
    ) -> std::io::Result<Self>, fn full_recompute_root(&self) -> Hash, fn rehash_with_new_capacity(&mut self, required_leaves: u64) }  (line 30)

hash/mod.rs:
  trait HashBackend  (line 3)

hash/gpu.rs:
  struct GpuBackend  { _ctx }  (line 6)
  struct CudaContext  { stream }  (line 10)
  impl Send for CudaContext  (line 17)
  impl Sync for CudaContext  (line 18)
  impl CudaContext  { fn new() -> Self }  (line 20)
  impl Drop for CudaContext  { fn drop(&mut self) }  (line 34)
  impl GpuBackend  { fn allocate_tree_bytes(bytes: usize) -> *mut u8, fn free_tree(ptr: *mut u8) }  (line 42)
  impl HashBackend for GpuBackend  { fn rebuild_merkle_tree(&self, nodes: &mut [Hash], tree_size: u64, pages_ptr: *const u8) }  (line 75)
  fn create_gpu_backend() -> Box<dyn HashBackend>  (line 87)

page_store.rs:
  struct PageStore  { ptr, capacity }  (line 11)
  impl Send for PageStore  (line 18)
  impl Sync for PageStore  (line 19)
  impl PageStore  { fn in_memory() -> Self, fn write_page(&mut self, page_id: u64, data: &[u8]), fn read_page(&self, page_id: u64) -> &[u8], fn flush(&mut self) -> std::io::Result<()>, fn as_device_ptr(&self) -> *const u8, fn capacity_bytes(&self) -> usize, fn grow(&mut self, required: usize) }  (line 21)
  impl Drop for PageStore  { fn drop(&mut self) }  (line 102)

engine.rs:
  trait Engine  (line 13)

proofs.rs:
  struct JudgmentProof  { approved, timestamp, hash }  (line 11)
  impl JudgmentProof  { fn hash(&self) -> Hash }  (line 17)
  struct AdmissionProof  { judgment_proof_hash, epoch, nonce }  (line 25)
  impl AdmissionProof  { fn hash(&self) -> Hash }  (line 31)
  struct CommitProof  { admission_proof_hash, delta_hash, state_hash }  (line 39)
  impl CommitProof  { fn hash(&self) -> Hash }  (line 45)
  struct OutcomeProof  { commit_proof_hash, success }  (line 53)
  impl OutcomeProof  { fn hash(&self) -> Hash }  (line 58)

delta/delta_types.rs:
  struct Source  (line 11)
  enum DeltaError  { SizeMismatch, PageIDMismatch, MaskSizeMismatch }  (line 14)

delta/delta.rs:
  struct Delta  { delta_id, page_id, epoch, mask, payload, is_sparse, timestamp, source, intent_metadata }  (line 13)
  impl Delta  { fn new_dense(
        delta_id: DeltaID,
        page_id: PageID,
        epoch: Epoch,
        data: Vec<u8>,
        mask: Vec<bool>,
        source: Source,
    ) -> Result<Self, DeltaError>, fn new_sparse(
        delta_id: DeltaID,
        page_id: PageID,
        epoch: Epoch,
        mask: Vec<bool>,
        payload: Vec<u8>,
        source: Source,
    ) -> Result<Self, DeltaError>, fn merge(&self, other: &Delta) -> Result<Delta, DeltaError>, fn to_dense(&self) -> Vec<u8>, fn apply_to(&self, page: &mut Page) -> Result<(), PageError>, fn hash(&self) -> Hash }  (line 25)
  fn now_ns() -> u64  (line 161)

delta/delta_validation.rs:
  fn validate_delta(delta: &Delta) -> Result<(), DeltaError>  (line 4)

delta/shell_delta.rs:
  struct ShellDelta  { shell_id, epoch, command, state_hash }  (line 14)
  enum ShellDeltaError  { MissingHeader, UnsupportedVersion, Serialization, Delta }  (line 22)
  impl From<serde_json::Error> for ShellDeltaError  { fn from(err: serde_json::Error) -> Self }  (line 33)
  impl ShellDelta  { fn new(
        shell_id: u64,
        epoch: u64,
        command: impl Into<String>,
        state_hash: impl Into<String>,
    ) -> Self, fn into_delta(
        &self,
        delta_id: DeltaID,
        page_id: PageID,
        epoch: Epoch,
    ) -> Result<Delta, ShellDeltaError>, fn try_from_delta(delta: &Delta) -> Result<Option<ShellDelta>, ShellDeltaError>, fn encode_payload(&self) -> Result<Vec<u8>, ShellDeltaError>, fn decode_payload(bytes: &[u8]) -> Result<Option<ShellDelta>, ShellDeltaError> }  (line 39)

engine_commit.rs:
  impl MemoryEngine  { fn commit_delta(
        &self,
        admission: &AdmissionProof,
        delta_hash: &Hash,
    ) -> Result<CommitProof, MemoryEngineError> }  (line 10)

persistence/mmap_log.rs:
  struct MmapLog  { file, mmap, write_offset }  (line 15)
  impl MmapLog  { fn open(path: &Path, size: usize) -> std::io::Result<Self>, fn append(&mut self, data: &[u8]) -> std::io::Result<()>, fn write_root_header(&mut self, header: &RootHeader) -> std::io::Result<()>, fn read_latest_root(&self) -> std::io::Result<Option<RootHeader>>, fn scan_records(&self) -> Vec<Vec<u8>>, fn flush(&mut self) -> std::io::Result<()>, fn truncate(&mut self) -> std::io::Result<()> }  (line 21)

persistence/root_header.rs:
  struct RootHeader  { generation, tree_size, root_hash }  (line 5)
  impl RootHeader  { fn is_valid(&self) -> bool }  (line 11)

tlog/tlog.rs:
  struct TransactionLog  { entries, writer, path }  (line 31)
  struct LogSummary  { total_deltas, total_bytes, last_epoch }  (line 39)
  impl TransactionLog  { fn new(path: impl Into<PathBuf>) -> std::io::Result<Self>, fn clear_entries(&self), fn append(&self, admission_proof: &AdmissionProof, delta: Delta) -> std::io::Result<()>, fn summary(&self) -> std::io::Result<LogSummary>, fn replay(&self, _start_epoch: u32) -> std::io::Result<Vec<Delta>>, fn current_offset(&self) -> std::io::Result<u64> }  (line 45)

epoch/gc.rs:
  struct GCMetrics  { reclaimed_pages, reclaimed_bytes, duration }  (line 5)
  trait MemoryPressureHandler  (line 12)

epoch/checkpoint.rs:
  fn write_checkpoint(
    allocator: &PageAllocator,
    _tlog: &(),
    path: impl AsRef<Path>,
) -> std::io::Result<()>  (line 12)
  fn load_checkpoint(
    allocator: &PageAllocator,
    _tlog: &(),
    path: impl AsRef<Path>,
) -> std::io::Result<()>  (line 39)

epoch/epoch_types.rs:
  struct Epoch  (line 19)
  impl Epoch  { fn new(value: u32) -> Self }  (line 21)
  struct EpochCell  { inner }  (line 29)
  impl EpochCell  { fn new(value: u32) -> Self, fn load(&self) -> Epoch, fn store(&self, value: Epoch), fn increment(&self) -> Epoch }  (line 33)

primitives.rs:
  type Hash  (line 10)
  struct PageID  (line 14)
  struct DeltaID  (line 18)
  struct Epoch  (line 22)
  type Timestamp  (line 25)
  type EventId  (line 28)
  impl std::fmt::Display for PageID  { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result }  (line 30)


