use std::fs;
use std::path::{Path, PathBuf};

use proc_macro2::Span;
use syn::spanned::Spanned;
use walkdir::WalkDir;

#[derive(Debug)]
struct FieldRecord {
    struct_name: String,
    field_name: String,
    path: PathBuf,
    line: usize,
}

fn main() {
    if let Err(err) = run() {
        eprintln!("layout inventory failed: {err}");
        std::process::exit(1);
    }
}

fn run() -> Result<(), Box<dyn std::error::Error>> {
    let crate_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let ir_root = crate_root.join("src/ir");
    let mut rows: Vec<FieldRecord> = Vec::new();

    for entry in WalkDir::new(&ir_root) {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        if path.extension().and_then(|ext| ext.to_str()) != Some("rs") {
            continue;
        }
        let source = fs::read_to_string(path)?;
        let parsed = syn::parse_file(&source)?;
        for item in parsed.items {
            if let syn::Item::Struct(item_struct) = item {
                rows.extend(layout_fields(path, &item_struct));
            }
        }
    }

    rows.sort_by(|a, b| {
        a.struct_name
            .cmp(&b.struct_name)
            .then_with(|| a.field_name.cmp(&b.field_name))
            .then_with(|| a.path.cmp(&b.path))
            .then(a.line.cmp(&b.line))
    });

    println!("# Layout Metadata Inventory\n");
    println!(
        "Generated by `cargo run --bin layout_inventory`. Lists every IR struct field that contains layout metadata (file IDs, module paths, or filesystem routing).\n"
    );
    println!("| Struct | Field | Location |");
    println!("| --- | --- | --- |");
    for row in rows {
        let rel = row
            .path
            .strip_prefix(&crate_root)
            .unwrap_or(&row.path)
            .display();
        println!(
            "| `{}` | `{}` | `{}` |",
            row.struct_name,
            row.field_name,
            format!("{}:{}", rel, row.line)
        );
    }

    Ok(())
}

fn layout_fields(path: &Path, item: &syn::ItemStruct) -> Vec<FieldRecord> {
    let mut rows = Vec::new();
    let syn::Fields::Named(named) = &item.fields else {
        return rows;
    };
    for field in &named.named {
        let Some(ident) = &field.ident else {
            continue;
        };
        let name = ident.to_string();
        if !is_layout_field(&name) {
            continue;
        }
        let span = field.span();
        let line = line_number(span);
        rows.push(FieldRecord {
            struct_name: item.ident.to_string(),
            field_name: name,
            path: path.to_path_buf(),
            line,
        });
    }
    rows
}

fn is_layout_field(name: &str) -> bool {
    static KEYWORDS: &[&str] = &["file", "module_path", "filesystem"];
    let lower = name.to_ascii_lowercase();
    KEYWORDS.iter().any(|kw| lower.contains(kw))
}

fn line_number(span: Span) -> usize {
    span.start().line as usize
}
