//! Parallel execution helpers for tick graphs.
//!
//! Builds batches of independent nodes and executes them concurrently using rayon.

use std::collections::{BTreeMap, HashMap, HashSet};
use std::sync::mpsc;

use rayon::scope;

use crate::ir::FunctionId;
use crate::runtime::executor::ExecutorError;
use crate::runtime::value::{DeltaValue, Value};

/// Work item scheduled for parallel execution.
#[derive(Debug)]
pub struct ParallelJob {
    pub function: FunctionId,
    pub inputs: BTreeMap<String, Value>,
}

/// Outputs generated by a parallel job.
#[derive(Debug)]
pub struct ParallelJobResult {
    pub function: FunctionId,
    pub outputs: BTreeMap<String, Value>,
    pub deltas: Vec<DeltaValue>,
}

/// Partition a topologically sorted order into batches where nodes share no dependencies.
pub fn partition_independent_batches(order: &[FunctionId], dependencies: &HashMap<FunctionId, Vec<FunctionId>>) -> Vec<Vec<FunctionId>> {
    let mut batches = Vec::new();
    let mut current = Vec::new();
    let mut blockers: HashSet<FunctionId> = HashSet::new();

    for node in order {
        let deps = dependencies.get(node).cloned().unwrap_or_default();
        let intersects = deps.iter().any(|dep| blockers.contains(dep));
        if intersects {
            if !current.is_empty() {
                batches.push(current);
                current = Vec::new();
            }
            blockers.clear();
        }

        blockers.insert(node.clone());
        blockers.extend(deps.clone());
        current.push(node.clone());
    }

    if !current.is_empty() {
        batches.push(current);
    }

    batches
}

/// Execute a batch of jobs in parallel using rayon and collect results via channel.
pub fn execute_jobs<F>(jobs: Vec<ParallelJob>, worker: &F) -> Result<Vec<ParallelJobResult>, ExecutorError>
where F: Sync + Send + Fn(&FunctionId, BTreeMap<String, Value>) -> Result<ParallelJobResult, ExecutorError> {
    let (tx, rx) = mpsc::channel();
    scope(|scope| {
        for job in jobs {
            let tx = tx.clone();
            let func = job.function.clone();
            let inputs = job.inputs;
            scope.spawn(move |_| {
                let result = worker(&func, inputs);
                let _ = tx.send((func, result));
            });
        }
    });
    drop(tx);

    let mut results = Vec::new();
    for (_func, result) in rx {
        let job_result = result?;
        results.push(job_result);
    }
    Ok(results)
}
