#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CanonRule {
    ExplicitArtifacts,
    ModuleDag,
    ModuleSelfImport,
    ImplBinding,
    ExecutionOnlyInImpl,
    FunctionContracts,
    EffectsAreDeltas,
    DeltaProofs,
    DeltaAppendOnly,
    CallGraphPublicApis,
    CallGraphRespectsDag,
    CallGraphAcyclic,
    TickGraphAcyclic,
    TickGraphEdgesDeclared,
    LoopContinuationJudgment,
    GpuLawfulMath,
    ProposalDeclarative,
    JudgmentDecisions,
    LearningDeclarations,
    TraitVerbs,
    TickRoot,
    ProjectEnvelope,
    ExternalDependencies,
    DeltaPipeline,
    ProofScope,
    VersionEvolution,
    TickEpochs,
    PlanArtifacts,
    ExecutionBoundary,
    AdmissionBridge,
    FunctionAst,
}

impl CanonRule {
    pub fn code(self) -> &'static str {
        match self {
            CanonRule::ExplicitArtifacts => "Rule 5",
            CanonRule::ModuleDag => "Rule 13",
            CanonRule::ModuleSelfImport => "Rule 14",
            CanonRule::ImplBinding => "Rule 26",
            CanonRule::ExecutionOnlyInImpl => "Rule 27",
            CanonRule::FunctionContracts => "Rules 31-34",
            CanonRule::EffectsAreDeltas => "Rules 34-38",
            CanonRule::DeltaProofs => "Rules 67-69",
            CanonRule::DeltaAppendOnly => "Rule 38",
            CanonRule::CallGraphPublicApis => "Rule 42",
            CanonRule::CallGraphRespectsDag => "Rule 43",
            CanonRule::CallGraphAcyclic => "Rules 49 & 75",
            CanonRule::TickGraphAcyclic => "Rules 48-50",
            CanonRule::TickGraphEdgesDeclared => "Rule 41",
            CanonRule::LoopContinuationJudgment => "Rule 52",
            CanonRule::GpuLawfulMath => "Rules 81-89",
            CanonRule::ProposalDeclarative => "Rules 57-59",
            CanonRule::JudgmentDecisions => "Rules 53-55",
            CanonRule::LearningDeclarations => "Rules 61-62",
            CanonRule::TraitVerbs => "Rule 23",
            CanonRule::TickRoot => "Rules 46-51",
            CanonRule::ProjectEnvelope => "Rules 5-8",
            CanonRule::ExternalDependencies => "Rule 5",
            CanonRule::DeltaPipeline => "Rules 50-79",
            CanonRule::ProofScope => "Rules 63-69",
            CanonRule::VersionEvolution => "Rule 99",
            CanonRule::TickEpochs => "Rules 46-51",
            CanonRule::PlanArtifacts => "Rules 57-60",
            CanonRule::ExecutionBoundary => "Rules 46-55",
            CanonRule::AdmissionBridge => "Rules 53-69",
            CanonRule::FunctionAst => "Rule 27",
        }
    }

    pub fn text(self) -> &'static str {
        match self {
            CanonRule::ExplicitArtifacts => "All referenced artifacts must exist and remain unique.",
            CanonRule::ModuleDag => "Modules must form a strict acyclic DAG.",
            CanonRule::ModuleSelfImport => "Modules may not import themselves.",
            CanonRule::ImplBinding => "Impl blocks must bind nouns to verbs lawfully.",
            CanonRule::ExecutionOnlyInImpl => "Execution may only occur inside impl blocks.",
            CanonRule::FunctionContracts => "Functions must be total with explicit IO and delta effects.",
            CanonRule::EffectsAreDeltas => "All effects must surface as declared deltas.",
            CanonRule::DeltaProofs => "Every delta must carry an attached proof obligation.",
            CanonRule::DeltaAppendOnly => "Deltas must be append-only artifacts.",
            CanonRule::CallGraphPublicApis => "Call edges may target public APIs only.",
            CanonRule::CallGraphRespectsDag => "Call graphs must respect module import permissions.",
            CanonRule::CallGraphAcyclic => "No recursion or cycles are allowed in execution.",
            CanonRule::TickGraphAcyclic => "Each tick graph must be acyclic.",
            CanonRule::TickGraphEdgesDeclared => "Tick graphs must align with the call graph.",
            CanonRule::LoopContinuationJudgment => "Loop continuation is a judgment decision.",
            CanonRule::GpuLawfulMath => "GPU kernels may contain lawful math only.",
            CanonRule::ProposalDeclarative => "Proposals must enumerate goals, nodes, APIs, and edges.",
            CanonRule::JudgmentDecisions => "Judgment references must be explicit and structural.",
            CanonRule::LearningDeclarations => "Learning proposals must be explicit artifacts.",
            CanonRule::TraitVerbs => "Traits declare verbs/capabilities in a unique namespace.",
            CanonRule::TickRoot => "Each IR instance must declare explicit tick roots.",
            CanonRule::ProjectEnvelope => "Projects must declare their package envelope.",
            CanonRule::ExternalDependencies => "External dependencies must be explicit and unique.",
            CanonRule::DeltaPipeline => "Pipeline stages may emit only lawful delta kinds.",
            CanonRule::ProofScope => "Delta proofs must match their semantic scope.",
            CanonRule::VersionEvolution => "Version upgrades require explicit law-scoped proofs.",
            CanonRule::TickEpochs => "Ticks must belong to an acyclic epoch hierarchy.",
            CanonRule::PlanArtifacts => "Plans must reference accepted judgments and lawful steps.",
            CanonRule::ExecutionBoundary => "Execution results must reference known plans, ticks, and deltas.",
            CanonRule::AdmissionBridge => "Admissions bridge judgments to applied deltas deterministically.",
            CanonRule::FunctionAst => "UpdateFunctionAst delta must reference an existing function.",
        }
    }
}
